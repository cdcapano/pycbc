#! /usr/bin/env python
# Copyright (C) 2016  Collin Capano
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#
__description__ = \
""""Loads a bank of waveforms and compresses them using the specified
compression algorithm. The resulting compressed waveforms are saved to an
hdf file."""

import argparse
import numpy
import h5py
import logging
import pycbc
from pycbc.waveform import compress
from pycbc import waveform
from pycbc.types import FrequencySeries
from pycbc import pnutils
from pycbc import filter

def _vecdiff(htilde, hinterp, fmin, fmax):
    return abs(filter.overlap_cplx(htilde, htilde,
                          low_frequency_cutoff=fmin,
                          high_frequency_cutoff=fmax,
                          normalized=False)
                - filter.overlap_cplx(htilde, hinterp,
                          low_frequency_cutoff=fmin,
                          high_frequency_cutoff=fmax,
                          normalized=False))

def vecdiff(htilde, hinterp, sample_points):
    """Computes a statistic indicating between which sample points a waveform
    and the interpolated waveform differ the most.
    """
    vecdiffs = numpy.zeros(sample_points.size-1, dtype=float)
    for kk,thisf in enumerate(sample_points[:-1]):
        nextf = sample_points[kk+1]
        vecdiffs[kk] = abs(_vecdiff(htilde, hinterp, thisf, nextf))
    return vecdiffs

def compress_waveform(htilde, sample_points, precision, interpolation,
        decomp_scratch=None):
    """Adds frequency points in order to ensure that the interpolated waveform
    has a mismatch with the full waveform that is <= the desired precision.
    """
    fmin = sample_points.min()
    df = htilde.delta_f
    sample_index = (sample_points / df).astype(int)
    amp = waveform.amplitude_from_frequencyseries(htilde)
    phase = waveform.phase_from_frequencyseries(htilde)

    comp_amp = amp.take(sample_index)
    comp_phase = phase.take(sample_index)
    hdecomp = compress.fd_decompress(comp_amp, comp_phase, sample_points,
        out=decomp_scratch, f_lower=fmin, interpolation=args.interpolation)
    mismatch = 1. - filter.overlap(hdecomp, htilde, low_frequency_cutoff=fmin)
    if mismatch > precision:
        # we'll need the difference in the waveforms as a function of frequency
        vecdiffs = vecdiff(htilde, hdecomp, sample_points)

    # We will find where in the frequency series the interpolated waveform
    # has the smallest overlap with the full waveform, add a sample point
    # there, and re-interpolate. We repeat this until the overall mismatch
    # is > than the desired precision 
    added_points = []
    while mismatch > args.precision:
        minpt = vecdiffs.argmax()
        # add a point at the frequency halfway between minpt and minpt+1
        add_freq = sample_points[[minpt, minpt+1]].mean()
        addidx = int(add_freq/df)
        new_index = numpy.zeros(sample_index.size+1, dtype=int)
        new_index[:minpt+1] = sample_index[:minpt+1]
        new_index[minpt+1] = addidx
        new_index[minpt+2:] = sample_index[minpt+1:]
        sample_index = new_index
        sample_points = sample_index * df
        # get the new compressed points
        comp_amp = amp.take(sample_index)
        comp_phase = phase.take(sample_index)
        # update the vecdiffs and mismatch
        hdecomp = compress.fd_decompress(comp_amp, comp_phase, sample_points,
            out=decomp_scratch, f_lower=fmin, interpolation=args.interpolation)
        new_vecdiffs = numpy.zeros(vecdiffs.size+1)
        new_vecdiffs[:minpt] = vecdiffs[:minpt]
        new_vecdiffs[minpt+2:] = vecdiffs[minpt+1:]
        new_vecdiffs[minpt:minpt+2] = vecdiff(htilde, hdecomp,
            sample_points[minpt:minpt+2])
        vecdiffs = new_vecdiffs
        mismatch = 1. - filter.overlap(hdecomp, htilde,
            low_frequency_cutoff=fmin)
        added_points.append(addidx)
    logging.info("mismatch: %f, N points: %i (%i added)" %(mismatch,
        len(comp_amp), len(added_points)))
    return comp_amp, comp_phase, mismatch, numpy.array(added_points)*df


parser = argparse.ArgumentParser(description=__description__)
parser.add_argument("--bank-file", type=str,
                help="Bank hdf file to load.")
parser.add_argument("--output", type=str,
                help="The hdf file to save the templates and compressed "
                     "waveforms to.")
parser.add_argument("--low-frequency-cutoff", type=float, required=True,
                help="The low frequency cutoff to use for generating "
                     "the waveforms (Hz)")
parser.add_argument("--approximant", type=str,
                help="The approximant to generate the waveforms with. If "
                     "none provided, will attempt to retrieve the approximant "
                     "from the bank file.")
parser.add_argument("--sample-rate", type=int, required=True,
                help="Half this value sets the maximum frequency of the "
                     "compressed waveforms.")
parser.add_argument("--segment-length", type=float, required=True,
                help="The inverse of this sets the delta-f used for "
                     "generating waveforms prior to compressing.")
parser.add_argument("--tmplt-index", nargs=2, type=int, default=None,
                help="Only generate compressed waveforms for the given "
                     "indices in the bank file. Must provide both a start "
                     "and a stop index. Default is to compress all of the "
                     "templates in the bank file.")
parser.add_argument("--compression-algorithm", type=str, required=True,
                choices=compress.compression_algorithms.keys(),
                help="The compression algorithm to use for selecting "
                     "frequency points.")
parser.add_argument("--t-pad", type=float, default=0.001,
                help="The minimum duration used for t(f) in seconds. The "
                     "inverse of this gives the maximum frequency step that "
                     "will be used in the compressed waveforms. Default is "
                     "0.001.")
parser.add_argument("--precision", type=float, default=0.001,
                help="The maximum mismatch to allow between the interpolated "
                     "waveform must and the full waveform. Points will be "
                     "added to the compressed waveform until its "
                     "interpolation has a mismatch <= this value. Default is "
                     "0.001.")
parser.add_argument("--interpolation", type=str, default="linear",
                help="The interpolation to use for decompressing the "
                     "waveforms for checking precision. Options are 'linear', "
                     "or any interpolation recognized by scipy's interp1d "
                     "kind argument. Default is linear.")
parser.add_argument("--save-added-points", action="store_true", default=False,
                help="Save the indices of points that had to be added in "
                     "order for the mismatch to be <= the desired precision.")
parser.add_argument("--verbose", action="store_true", default=False)


args = parser.parse_args()

pycbc.init_logging(args.verbose)

df = 1./args.segment_length
fmin = args.low_frequency_cutoff
fmax = args.sample_rate/2.
# figure out the length of the full waveforms in the frequency domain
N = int(args.sample_rate*args.segment_length/2 + 1)
# scratch space
scratch = FrequencySeries(numpy.zeros(N, dtype=numpy.complex128), delta_f=df)
decomp_scratch = FrequencySeries(numpy.zeros(N, dtype=numpy.complex128),
                                 delta_f=df)
# we'll need the full frequency series
allf = numpy.arange(N)*df

# load the bank
logging.info("loading bank")
# Note: we'll budge the waveform starting frequency down by 1df to ensure the
# first point is correct
bank = waveform.FilterBank(args.bank_file, N, df, fmin-df, numpy.complex128,
    approximant=args.approximant, out=scratch)
templates = bank.table
if args.tmplt_index is not None:
    imin, imax = args.tmplt_index
    templates = templates[imin:imax]
else:
    imin, imax = 0, templates.size

# generate output file
# FIXME: this should be moved to a class or function
logging.info("writing template info to output")
output = h5py.File(args.output, 'w')
output['mass1'] = templates['mass1']
output['mass2'] = templates['mass2']
output['spin1z'] = templates['spin1z']
output['spin2z'] = templates['spin2z']
output['template_hash'] = templates['template_hash']

# get the compressed sample points for each template
logging.info("getting compressed amplitude and phase")
mismatches = numpy.zeros(imax-imin, dtype=float)
for ii in range(imin, imax):

    htilde = bank[ii]
    tmplt = bank.table[ii]
    kmax = htilde.end_idx
    
    # get the compressed sample points
    if args.compression_algorithm == 'mchirp':
        sample_points = compress.mchirp_compression(tmplt.mass1, tmplt.mass2,
            fmin, (kmax-1)*df, min_seglen=args.t_pad, df_multiple=df)
    elif args.compression_algorithm == 'spa':
        sample_points = compress.spa_compression(htilde, fmin, (kmax-1)*df,
            min_seglen=args.t_pad, sample_frequencies=allf)
    else:
        raise ValueError("unrecognized compression algorithm %s" %(
            args.compression_algorithm))
            
    # compress
    comp_amp, comp_phase, mismatch, added_points = compress_waveform(
        htilde, sample_points, args.precision, args.interpolation,
        decomp_scratch=decomp_scratch)

    mismatches[ii-imin] = mismatch

    # save results
    output['compressed_waveforms/%i/amplitude' %(ii-imin)] = comp_amp.numpy()
    output['compressed_waveforms/%i/phase' %(ii-imin)] = comp_phase.numpy()
    output['compressed_waveforms/%i/frequency' %(ii-imin)] = sample_points
    #output['compressed_waveforms/%i' %(ii - imin)].attrs['mismatch'] = mismatch
    if args.save_added_points:
        output['compressed_waveforms/%i/added_points' %(ii - imin)] = \
            added_points

output['compressed_waveforms/mismatch'] = mismatches
# save metadata
output['compressed_waveforms'].attrs['interpolation'] = args.interpolation
output['compressed_waveforms'].attrs['precision'] = args.precision

logging.info("finished")
output.close()
