#! /usr/bin/env python

import os
import sys
import sqlite3

from pycbc.overlaps import overlap_utils
import numpy
from optparse import OptionParser

from pycbc import plot
from pycbc.plot import data_utils
from pycbc.plot import overlaps

parser = OptionParser()
parser.add_option('-c', '--cache-file', help = 'cache file containing results databases')
parser.add_option('-o', '--plot-directory', default = '.', help = 'directory to save plot(s) to. Default is current.')
parser.add_option('-u', '--user-tag', help = 'user tag for plot(s)')
parser.add_option('-p', '--param-name', metavar='param_name[:param_label]', help = 'Name of the parameter to plot. Can optionally also specify a label to use for the parameter for the plots.')
parser.add_option('-W', '--weight-function', default='uniform', help="Plot results for the given weight function. Default is 'uniform'. The weight name provided must exist in the description column of the coinc_definer table.")
parser.add_option('--plot-zoom', action='store_true', default=False, help='Create a second axis zoomed onto the desired area. Zoom limits are set by zoom-xlims and zoom-ylims.')
parser.add_option('--zoom-xlims', metavar='xmin,xmax', help = 'X-limits for zoomed axis. If not specified, will be the same as the full plot.')
parser.add_option('--zoom-ylims', metavar='ymin,ymax', help = 'Y-limits for zoomed axis. If not specified, will be the same as the full plot.')
parser.add_option('', '--simple-window', metavar='LOWER[:UPPER]', help="Optional. Plot a simple window around the plotting parameter. LOWER must be < 1. If an UPPER is not specified, the LOWER fractional range will be used.")
parser.add_option('--param-window-db', help='Optional. Plot the parameter window in the given database. One of the parameters listed in the database must be the same as param-name.')
parser.add_option('--plot-effectualness', action='store_true', default=False, help='Optional. Color points by their effectualness.')
parser.add_option('-D', '--dpi', type = 'int', default = 300, help = 'dpi to use for plots')
parser.add_option('-S', '--point-size', type = 'int', default=3, help='point size to use for markers; default is 3.')
parser.add_option('-A', '--x-min', type = 'float', help = 'min x for plot')
parser.add_option('-B', '--x-max', type = 'float', help = 'max x for plot')
parser.add_option('-U', '--y-min', type = 'float', help = 'min y for plot')
parser.add_option('-V', '--y-max', type = 'float', help = 'max y for plot')
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help = 'apply cut to injections; can specify multiple times')

opts, _ = parser.parse_args()

if opts.zoom_xlims is not None:
    opts.zoom_xlims = map(float, opts.zoom_xlims.split(','))
if opts.zoom_ylims is not None:
    opts.zoom_ylims = map(float, opts.zoom_ylims.split(','))

if opts.param_name is None:
    raise ValueError, '--param-name is required' 
if len(opts.param_name.split(':')) == 2:
    param_name, param_label = map(str.strip, opts.param_name.split(':'))
else:
    param_name = param_label = opts.param_name.strip()

if opts.user_tag is not None:
    tag = '_%s' % opts.user_tag
else:
    tag = ''

if opts.param_window_db is not None and opts.simple_window is not None:
    raise ValueError("Cannot use a match-window-db and a simple-window at " +
        "the same time. Please choose one, or neither.")

# get the param windows if desired
if opts.simple_window is not None:
    win_settings = opts.simple_window.split(':')
    try:
        min_jitter, max_jitter = win_settings
    except ValueError:
        # max_jitter not specified
        try:
            min_jitter = win_settings
            max_jitter = min_jitter
        except ValueError:
            # option not configured properly
            raise ValueError("Simple-window arguments not formatted " +
                "correctly; see help message.")
    min_jitter = -1.*float(min_jitter)
    if abs(min_jitter) > 1.:
        raise ValueError("Lower bound of simple-window cannot be > 1; " +
            "see help message.")
    max_jitter = float(max_jitter)
    pwin = overlap_utils.ParamWindow(-numpy.inf, numpy.inf)
    pwin.set_jitter(min_jitter, max_jitter)
    pw_list = overlap_utils.ParamWindowList()
    pw_list.append(pwin)
elif opts.param_window_db is not None:
    connection = sqlite3.connect(opts.param_window_db)
    pw_list = overlap_utils.ParamWindowList()
    pw_list.load_from_database(connection, param_name)
    connection.close()
else:
    pw_list = None


apply_cut = {}
for thiscut in opts.apply_cut:
    arg, vals = thiscut.split(':')
    apply_cut[arg] = map(float, vals.split(','))

print "getting results"
filenames = plot.parse_results_cache(opts.cache_file)
results, _ = plot.overlaps.get_injection_results(filenames,
    weight_function=opts.weight_function, verbose=True)
if apply_cut:
    print "applying cuts"
    results = plot.slice_results(results, apply_cut)

inj_params = numpy.array([data_utils.get_arg(res, param_name) \
    for res in results])
rec_params = numpy.array([data_utils.get_arg(res, 'template.'+param_name) \
    for res in results])

if opts.plot_effectualness:
    effectualness = numpy.array([res.effectualness for res in results])
else:
    effectualness = []

if pw_list is not None:
    # figure out what's missed by the parameter windows
    print "getting injections that would be missed by the parameter windows"
    missed_indices = [nn for nn,(recval, injval) in \
        enumerate(zip(rec_params, inj_params)) if recval not in \
        pw_list[pw_list.find(injval)].recovery_window(injval)]
else:
    missed_indices = None

print "plotting"
fig = overlaps.plot_followup.plot_recovered_injected(inj_params, rec_params, param_label,
    param_windows=pw_list, pwin_missed_indices=missed_indices,
    xmin=opts.x_min, xmax=opts.x_max, ymin=opts.y_min, ymax=opts.y_max,
    plot_zoom=opts.plot_zoom, zoom_xlims=opts.zoom_xlims,
    zoom_ylims=opts.zoom_ylims, point_size=opts.point_size,
    effectualness=effectualness)

fig.savefig('%s/plot_injrec%s.png' %(opts.plot_directory, tag), dpi=opts.dpi,
    bbox_inches='tight')
