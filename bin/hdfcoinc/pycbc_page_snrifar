#!/usr/bin/python
""" Make table of the foreground coincident events
"""
import argparse, h5py, numpy, logging, sys, lal
import matplotlib
matplotlib.use('Agg')
import pylab, pycbc.results, pycbc.version
from scipy import special

def p_from_sigma(sig):
    return special.erfc((sig)/numpy.sqrt(2))/2.

def p_from_far(far, livetime):
    return 1 - numpy.exp(-far * livetime)

def sigma_from_p(p):
    return numpy.sqrt(2) * special.erfcinv(2*p)
    
pylab.rc('text', usetex=True)
pylab.rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})

parser = argparse.ArgumentParser()
# General required options
parser.add_argument('--version', action='version', version=pycbc.version.git_verbose_msg)
parser.add_argument('--trigger-file')
parser.add_argument('--verbose', action='count')
parser.add_argument('--output-file')
parser.add_argument('--trials-factor', type=int, default=1)
parser.add_argument('--not-cumulative', action='store_true')
parser.add_argument('--closed-box', action='store_true',
      help="Make a closed box version that excludes foreground triggers")
parser.add_argument('--ymin', type=float, help='Set the minimum value of the y-axis (in units of 1/years)')
parser.add_argument('--ymax', type=float, help='Set the maximum value of the y-axis (in units of 1/years)')
args = parser.parse_args()

args.cumulative = not args.not_cumulative

if args.verbose:
    log_level = logging.INFO
    logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)
    
logging.info('Read in the data')
f = h5py.File(args.trigger_file, 'r')

foreground_livetime = f.attrs['foreground_time'] / lal.YRJUL_SI
try:
    cstat_fore = f['foreground/stat'][:]
    
    if args.cumulative:
        cstat_fore.sort()
        cstat_rate = numpy.arange(len(cstat_fore), 0, -1) / f.attrs['foreground_time'] * 3.15569e7 \
            * args.trials_factor
    else:
        ssort = cstat_fore.argsort()
        cstat_rate = 1.0 / f['foreground/ifar'][:] * args.trials_factor
        cstat_rate = cstat_rate[ssort]
        cstat_fore = cstat_fore[ssort]
        cstat_fap = p_from_far(cstat_rate, foreground_livetime)
    
    logging.info('Found %s foreground triggers' % len(cstat_fore))
except:
    cstat_fore = None

back_ifar = f['background/ifar'][:]
cstat_back = f['background/stat'][:]
back_sort = cstat_back.argsort()
cstat_back = cstat_back[back_sort]
far_back = 1.0 / back_ifar[back_sort] * args.trials_factor
fap_back = p_from_far(far_back, foreground_livetime)

# we'll use the background far for the ylimits
if args.ymin is None:
    plot_ymin = far_back.min()/10.
else:
    plot_ymin = args.ymin
if args.ymax is None:
    plot_ymax = far_back.max()
else:
    plot_ymax = args.ymax

logging.info('Found %s background (inclusive zerolag) triggers' % len(cstat_back))

back_ifar_exc = f['background_exc/ifar'][:]
cstat_back_exc = f['background_exc/stat'][:]
back_sort_exc = cstat_back_exc.argsort()
cstat_back_exc = cstat_back_exc[back_sort_exc]
far_back_exc = 1.0 / back_ifar_exc[back_sort_exc] * args.trials_factor
logging.info('Found %s background (exclusive zerolag) triggers' % len(cstat_back_exc))

fig = pylab.figure(1)
pylab.scatter(cstat_back_exc, far_back_exc, color='gray', marker='.', s=20, label='Closed Box Background')

def pretty_num(num):
    exp = numpy.floor(numpy.log10(num))
    val = num / 10.0 ** exp
    return '%2.1fe%.0f' % (val, exp)

if not args.closed_box:
    pylab.scatter(cstat_back, far_back, color='black', marker='.', s=20, label='Open Box Background')

    if cstat_fore is not None and len(cstat_fore):
        pylab.scatter(cstat_fore, cstat_rate, s=60, color='#ff6600',
                                  marker='d', label='Foreground', zorder=100,
                                  linewidth=0.5, edgecolors='white')
        pylab.xlim(cstat_back.min(), max(cstat_fore.max(), cstat_back.max()) + 1)
    else:
        pylab.xlim(cstat_back.min(), cstat_back.max() + 1)

    if args.cumulative:
        sigmas = numpy.array([5, 4, 3, 2, 1])
        top = cstat_rate.max()
        for i in range(len(sigmas) - 1):
            p1 = p_from_sigma(sigmas[i])
            p2 = p_from_sigma(sigmas[i+1])
            
            
            #offset the shading so it is valid for the foreground beyond the first point
            if cstat_fore is not None and len(cstat_fore):
                offset = numpy.interp(cstat_back, cstat_fore, cstat_rate - cstat_rate[-1])
            else:
                offset = 0
                
            low = far_back / (1 - p2) * args.trials_factor + offset
            high = far_back / (1 - p1) * args.trials_factor + offset
            pylab.fill_between(cstat_back, low, high,
                               linewidth=0, color=pylab.cm.Blues(sigmas[i] / 5.0), zorder=-1)

            left = cstat_back[high < top].min()
            print left, top, sigmas[i]
            pylab.text(left, top, r"\textbf{%s $\sigma$}"  % sigmas[i], fontsize=8)
            

    else:
        # add arrows to any points > the loudest background
        louder_pts = numpy.where(cstat_fore > cstat_back.max())[0] 
        for ii in louder_pts:
            r = cstat_fore[ii]
            arr_start = cstat_rate[ii]
            # make the arrow length 1/15 the height of the plot
            arr_end = arr_start * (plot_ymin/plot_ymax)**(1./15)
            pylab.plot([r, r], [arr_start, arr_end], lw=2, color='#ff6600',
                zorder=99)
            pylab.plot([r, r], [arr_start, arr_end], lw=2.6, color='white',
                zorder=97)
            pylab.scatter([r], [arr_end], marker='v', c='#ff6600',
                edgecolors='white', lw=0.5, s=40, zorder=98)
        
        # add second y-axis for probabilities, sigmas
        sigmas = numpy.arange(6)+1
        ax1 = pylab.gca()
        ax1.set_axis_bgcolor('none')
        ax2 = ax1.twinx()
        ax1.set_zorder(ax2.get_zorder()+1) # put axis1 on top
        pylab.sca(ax2)
        ax2.semilogy()
        # where to stick the sigma lables
        plot_xmin, plot_xmax = ax1.get_xlim()
        anntx = plot_xmax - (plot_xmax - plot_xmin)/25.
        sigps = p_from_sigma(sigmas)
        for ii,p in enumerate(sigps[:-1]):
            nextp = sigps[ii+1]
            pylab.axhspan(nextp, p,
                        linewidth=0, color=pylab.cm.Blues(float(sigmas[ii+1]) / sigmas.size),
                        alpha=0.3, zorder=-1) 
            # add sigma label
            pylab.annotate('%1.0f$\sigma$' % sigmas[ii], (anntx, p), zorder=100)

        pylab.sca(ax1)
    
if args.cumulative:
    pylab.ylabel('Cumulative Rate (yr$^{-1}$)')   
else:
    if args.trials_factor == 1:
        pylab.ylabel('False Alarm Rate (yr$^{-1}$)')
    elif args.trials_factor >= 1:
        pylab.ylabel('Combined False Alarm Rate (yr$^{-1}$)')

pylab.xlabel(r'Network SNR, $\rho_c$')
pylab.yscale('log')
pylab.ylim(plot_ymin, plot_ymax)

if args.cumulative:
    pylab.legend(loc="lower left")
else:
    pylab.legend(loc="upper right")
    ax2.set_yscale('log')
    ymin, ymax = ax1.get_ylim()
    ax2.set_ylim(p_from_far(ymin, foreground_livetime),
                 p_from_far(ymax, foreground_livetime))
    
pylab.grid()

pycbc.results.save_fig_with_metadata(fig, args.output_file,
     title="%s bin, FAR vs Rank" % f.attrs['name'] if 'name' in f.attrs else "FAR vs Rank", 
     caption="Mapping between the ranking statistic and false alarm rate: "
             "Orange triangles (if present) represent triggers from the "
             " zero-lag (foreground) analysis. Solid crosses show "
             "the background inclusive of zerolag events, and grey crosses show the "
             " background constructed without triggers that are"
             " coincident in the zero-lag data.",
     cmd=' '.join(sys.argv))
             
pylab.savefig(args.output_file, dpi=300, bbox_limits='tight')

