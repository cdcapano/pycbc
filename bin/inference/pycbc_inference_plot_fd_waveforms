#! /usr/bin/env python

# Copyright (C) 2020 Collin Capano
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Makes a plot of recovered waveforms from an inference analysis."""


import argparse
import logging
import sys

import numpy

import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot

import pycbc
import pycbc.version
from pycbc.results.plot import (add_style_opt_to_parser, set_style_from_cli)
from pycbc.results import metadata
from pycbc import __version__
from pycbc.inference import (io, models)

# add options to command line
parser = argparse.ArgumentParser()
# program-specific
parser.add_argument("--input-file", required=True,
                    help="Path to input file. Must be either an inference "
                         "file or a posterior file.")
parser.add_argument("--output-file", type=str, required=True,
                    help="Path to output plot.")
parser.add_argument("--plot", required=True, nargs="+",
                    choices=["waveforms", "data", "residual", "injection",
                             "gated_waveforms", "gated_data", "gated_residual",
                             "gated_injection"],
                    help="What to plot: a waveform, the data, and/or the "
                         "injection (if it exists). In addition, if the "
                         "model used is GatedGaussian, can also plot gated "
                         "versions.")
group = parser.add_mutually_exclusive_group()
group.add_argument("--whiten", action="store_true", default=False,
                   help="Plot whitened data/waveforms/injection.")
group.add_argument("--overwhiten", action="store_true", default=False,
                   help="Plot over-whitened data/waveforms/injection.")
parser.add_argument("--waveform-selection", choices=["maxl"], default="maxl",
                    help="How to select the waveform for plotting. Default is "
                         "maxl (= maximum likelihood).")
parser.add_argument("--time-slice", nargs=2, type=float)
parser.add_argument("--reference-time",
                    help="Reference time for the time-slice. Can specify a "
                         "GPS time, 'trigger-time', or 'maxltc'. If not "
                         "provided, the x-axis will just be in terms of GPS " 
                         "seconds.")
parser.add_argument("--xmin", type=float)
parser.add_argument("--xmax", type=float)
parser.add_argument("--ymin", type=float)
parser.add_argument("--ymax", type=float)
parser.add_argument('--dpi', type=int, default=200,
                    help="Set the DPI of the plot. Default is 200.")
# boiler plate stuff
parser.add_argument("--version", action="version", version=__version__,
                    help="Prints version information.")
parser.add_argument("--verbose", action="store_true", default=False,
                    help="Be verbose")
# style option
add_style_opt_to_parser(parser)

# parse command line
opts = parser.parse_args()

# set mpl style
set_style_from_cli(opts)

# set logging
pycbc.init_logging(opts.verbose)

if opts.whiten:
    whiten = 1
elif opts.overwhiten:
    whiten = 2
else:
    whiten = False
    
logging.info("Setting up the model")
fp = io.loadfile(opts.input_file, 'r')
data = fp.read_data()
psds = fp.read_psds()
cp = fp.read_config_file()

model = models.read_from_config(cp, data=data, psds=psds)

if not (opts.plot == ["data"] and opts.reference_time != "maxltc"):
    # load samples
    logging.info("Loading samples")
    samples = fp.read_samples(list(fp['samples'].keys()))
    if opts.waveform_selection == "maxl":
        idx = samples['loglikelihood'].argmax()
    else:
        raise ValueError("Unrecoganized waveform selection option {}"
                         .format(opts.waveform_selection))
    params = {p: samples[p][idx] for p in samples.fieldnames}
    # ensure sampling transforms are turned off
    model.sampling_transforms = None
    model.update(**params)
    # call the likelihood to trigger any sort of waveform transforms
    _ = model.loglikelihood
fp.close()

if opts.reference_time == "maxltc":
    tref = model.current_params['tc']
elif opts.reference_time == "trigger_time":
    # try to get the trigger time from the config file
    tref = float(cp.get("data", "trigger-time"))
elif opts.reference_time is not None:
    tref = float(opts.reference_time)
else:
    tref = 0

# load the waveforms and data
logging.info("Loading frequency series")
frequency_series = {}
for plttype in opts.plot:
    thisfs = {}
    if plttype == "injection":
        injset = inject.InjectionSet(opts.input_file, hdf_group='injections')
        inj = injset.table[0]
        for det, d in data.items():
            h = injset.make_strain_from_inj_object(inj, d.delta_t, det)
            if opts.time_slice is not None:
                h = h.time_slice(opts.time_slice[0]+tref,
                                 opts.time_slice[1]+tref)
            thisfs[det] = h.to_frequencyseries()
    else:
        fds = getattr(model, 'get_{}'.format(plttype))(whiten=whiten)
        for det, dtilde in fds.items():
            if opts.time_slice is not None:
                d = dtilde.to_timeseries().time_slice(
                    opts.time_slice[0]+tref, opts.time_slice[1]+tref)
                dtilde = d.to_frequencyseries()
            thisfs[det] = dtilde
    frequency_series[plttype] = thisfs

logging.info("Plotting")
ncols = len(data.keys())
fwidth = ncols*3
fig, axes = pyplot.subplots(ncols=ncols, figsize=(fwidth, 3))
for ii, det in enumerate(data.keys()):
    logging.info(det)
    ax = axes[ii]
    ax.loglog()
    for plttype in frequency_series:
        lbl = plttype.replace('_', ' ')
        lbl = lbl.replace("waveforms", opts.waveform_selection)
        x = frequency_series[plttype][det]
        ax.plot(x.sample_frequencies, abs(x), lw=2, label=lbl)
        if opts.xmin is not None or opts.xmax is not None:
            ax.set_xlim(xmin=opts.xmin, xmax=opts.xmax)
        if opts.ymin is not None or opts.ymax is not None:
            ax.set_ylim(ymin=opts.ymin, ymax=opts.ymax)
    if ii == 0:
        # add the y label to the first axis
        if whiten == 1:
            ax.set_ylabel(r"whitened $\tilde{s}$")
        elif whiten == 2:
            ax.set_ylabel(r"over-whitened $\tilde{s}$")
        else:
            ax.set_ylabel(r"$\tilde{s}$")
    ax.set_title(det)
    ax.set_xlabel("frequency (Hz)")
    ax.grid(which='both')
# add the legend to the last axis
ax.legend()

# set DPI
fig.set_dpi(opts.dpi)

# save
metadata.save_fig_with_metadata(
                 fig, opts.output_file,
                 cmd=" ".join(sys.argv),
                 title="Waveforms",
                 caption="Waveforms and data.",
                 fig_kwds={'bbox_inches': 'tight'})

# finish
logging.info("Done")
