#! /usr/bin/env python
""" Plots the fraction of injections with their parameter value recovered
within a credible interval versus credible interval.
"""

import argparse
import logging
import matplotlib as mpl; mpl.use("Agg")
import matplotlib.colorbar as cbar
import matplotlib.pyplot as plt
import numpy
import pycbc
from scipy import stats
from matplotlib import cm
from pycbc import inject
from pycbc import transforms
from pycbc.inference import option_utils
from pycbc.io.record import FieldArray

# parse command line
parser = argparse.ArgumentParser(usage=__file__ + " [--options]",
                                 description=__doc__)
parser.add_argument("--output-file", required=True, type=str,
                    help="Path to save output plot.")
parser.add_argument("--verbose", action="store_true",
                    help="Allows print statements.")
parser.add_argument("--injection-hdf-group", default="H1/injections",
                    help="HDF group that contains injection values.")
option_utils.add_inference_results_option_group(parser)
option_utils.add_scatter_option_group(parser)
opts = parser.parse_args()

# set logging
pycbc.init_logging(opts.verbose)

# read results
_, parameters, labels, samples = option_utils.results_from_cli(opts)
labels = labels[0]

# typecast to list for iteration
parameters = [parameters] if not isinstance(samples, list) else parameters
labels = [labels] if not isinstance(labels, list) else labels
samples = [samples] if not isinstance(samples, list) else samples

# loop over input files and its samples
logging.info("Plotting")
measured_percentiles = {}
for input_file, input_parameters, input_samples in zip(
                                        opts.input_file, parameters, samples):

    # read injections from HDF input file
    injs = inject.InjectionSet(input_file, hdf_group=opts.injection_hdf_group)
    injs.table = injs.table.view(FieldArray)

    # check if need extra parameters than parameters stored in injection file
    _, ts = transforms.get_common_cbc_transforms(opts.parameters,
                                                 injs.table.fieldnames)

    # add parameters not included in injection file
    inj_parameters = transforms.apply_transforms(injs.table, ts)

    for p in input_parameters:

        inj_val = inj_parameters[p]
        sample_vals = input_samples[p]
        measured = stats.percentileofscore(sample_vals, inj_val, kind='weak')
        try:
            measured_percentiles[p].append(measured)
        except KeyError:
            measured_percentiles[p] = []
            measured_percentiles[p].append(measured)

# create figure for plotting
fig = plt.figure()
ax = fig.add_subplot(111)

# calculate the expected percentile for each injection and plot
for param,label in zip(input_parameters, labels):
    # calculate expected
    meas = numpy.array(measured_percentiles[param])
    meas.sort()
    expected = numpy.array([stats.percentileofscore(meas, x, kind='weak')
                            for x in meas])
    # perform ks test
    ks, p = stats.kstest(meas/100., 'uniform')
    ax.plot(meas/100., expected/100.,
                label='{} p-value: {:.3f}'.format(label, p))

# set legend
ax.legend()

# set labels
ax.set_ylabel(r"Fraction of Injections Recovered in Credible Interval")
ax.set_xlabel(r"Credible Interval")

# add grid to plot
ax.grid()

# add 1:1 line to plot
ax.plot([0, 1], [0, 1], linestyle="dashed", color="gray", zorder=9)

# save plot
plt.savefig(opts.output_file)

# done
logging.info("Done")

