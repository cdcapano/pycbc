#!/usr/bin/env python

# Copyright (C) 2020 Collin Capano, Richard Stiskalek
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""Makes a plot of MCMC parameters saved over checkpoint history.."""

import argparse

import numpy
import matplotlib
matplotlib.use('Agg')
from matplotlib import pyplot

import pycbc
from pycbc.inference import io

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('--input-file', type=str, required=True,
                    help='Path to the input HDF file.')
parser.add_argument('--output-file', type=str, required=True,
                    help='Name of the output plot.')
parser.add_argument('--plot-checkpoint-dt', action='store_true',
                    help='Plot the wall-clock time between checkpoints.')
parser.add_argument('--plot-act', action='store_true',
                    help='Plot ACT vs checkpoint iteration.')
parser.add_argument('--plot-effective-nsamples', action='store_true',
                    help='Plot the number of effective samples versus '
                         'checkpoint iteration.')
parser.add_argument('--plot-nchains-burned-in', action='store_true',
                    help='Plot the number of chains that were burned in '
                         'versus checkpoint iteration. Note that for '
                         'ensemble samplers, this will be all or nothing.')
opts = parser.parse_args()

pycbc.init_logging(True)

nplots = sum([opts.plot_act, opts.plot_effective_nsamples,
              opts.plot_nchains_burned_in, opts.plot_checkpoint_dt])
if nplots == 0:
    raise ValueError("nothing to plot")

# load the data
logging.info('Loading data')

fp = io.loadfile(opts.input_file, 'r')
history = fp['sampler_info/checkpoint_history']
iterations = history['niterations'][()]

if opts.plot_checkpoint_dt:
    checkpoint_dt = history['checkpoint_dt'][()]

if opts.plot_act:
    try:
        raw_acts = history['act'][()]
    except KeyError:
        raise ValueError("ACT history was not saved")
    if raw_acts.ndim == 2:
        # separate acts for each chain, calculate mean (of finite at each point)
        acts = numpy.full(raw_acts.shape[1], numpy.inf)
        for ii in range(raw_acts.shape[1]):
            aa = raw_acts[:, ii]
            aa = aa[numpy.isfinite(aa)]
            if aa.size > 0:
                acts[ii] = aa.mean()
    else:
        raw_acts = acts

if opts.plot_effctive_nsamples:
    nsamples = history['effective_nsamples'][()]

if opts.plot_nchains_burned_in:
    try:
        burn_in_iter = history['burn_in_iteration'][()]
    except KeyError:
        raise ValueError("Burn-in history not saved")
    nchains_burned_in = numpy.zeros(iterations.size, dtype=int)
    nchains = fp.nchains
    for ii, iteration in enumerate(iterations):
        if burn_in_iter.ndim == 1:
            # ensemble sampler; all or none
            nchains_burned_in[ii] = nchains*(burn_in_iter[ii] > iteration)
        else:
            nchains_burned_in[ii] = (burn_in_iter[:, ii] > iteration).sum()
fp.close()

# plot
logging.info("Plotting")
fig, axes = pyplot.subplots(nrows=nplots)
if nplots == 1:
    axes = [axes]
pi = -1
xmin = iterations.min()
xmax = iterations.max()

if opts.plot_checkpoint_dt:
    pi += 1
    ax = axes[pi]
    ax.plot(iterations, checkpoint_dt/60., lw=2)
    ax.set_ylabel('wallclock $\Delta t$ (m)')
    ax.set_xlim(xmin, xmax)

if opts.plot_act:
    pi += 1
    ax = axes[pi]
    ax.plot(iterations, acts, lw=2, zorder=1)
    if raw_acts.ndim == 2:
        # plot each of the chains separately
        for ii in range(raw_acts.shape[0]):
            ax.plot(iterations, raw_acts[ii, :], lw=0.5, color='black',
                    alpha=0.2,
                    zorder=0)
    ax.set_ylabel('ACT')
    ax.set_xlim(xmin, xmax)

if opts.plot_effective_nsamples:
    pi += 1
    ax = axes[pi]
    ax.plot(iterations, nsamples, lw=2, zorder=1)
    ax.set_ylabel(r'effective # samples')
    ax.set_xlim(xmin, xmax)

if opts.plot_nchains_burned_in:
    pi += 1
    ax = axes[pi]
    ax.plot(iterations, nchains_burned_in, lw=2, zorder=1)
    ax.set_ylabel(r'#/{} chains burned in'.format(nchains)
    ax.set_xlim(xmin, xmax)

ax.set_xlabel('iteration')
fig.savefig(opts.output_file)
