#! /usr/bin/env python

import os, sys
import sqlite3
from optparse import OptionParser
import math
import numpy
from pycbc import plot
from pycbc.plot import efficiency
from pycbc.plot import overlaps

__prog__ = 'pycbc_plot_effectualness'
__author__ = 'Collin Capano <collin.capano@ligo.org>'
__description__ = 'Makes scatter plots of the effectualness of a set of injections.'

parser = OptionParser(description=__description__)
parser.add_option('-c', '--cache-file', help = 'cache file containing result databases')
parser.add_option('-W', '--weight-function', default='uniform', help="Get effectualness for the given weight function. Default is 'uniform'. The weight name provided must exist in the description column of the coinc_definer table.")
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help='Only plot injections that have the given argument in the given range. Any argument in the list of plottable parameters can be used. If specified multiple times, only injections passing all specified cuts will be plotted.')
parser.add_option('', '--layer-config-file', help='If provided, a plot will be created for each tile in the given config file. All of the plot names will be written out to a cache file.')
parser.add_option('-t', '--plot-templates', action = 'store_true', default = False, help = 'plot the templates on top of the results')
parser.add_option('-x', '--x-val', metavar = 'args:label', help = 'x value to plot; see description for plottable arguments')
parser.add_option('-y', '--y-val', metavar = 'args:label', help = 'y value to plot; see description for plottable arguments')
parser.add_option('--log-x', action='store_true', default=False, help='Make x-axis log10.')
parser.add_option('--log-y', action='store_true', default=False, help='Make y-axis log10.')
parser.add_option('-X', '--x-lims', metavar = 'xmin,xmax', help = 'x limits to use')
parser.add_option('-Y', '--y-lims', metavar = 'ymin,ymax', help = 'y limits to use')
parser.add_option('-Z', '--z-lims', metavar = 'zmin,zmax', help = 'limits to use')
parser.add_option('-T', '--tmplt-label', default='', help='set a label for the templates. This will be placed in leading subscript in the colorbar label.')
parser.add_option('-I', '--inj-label', default='', help='set a label for the injections. This will be placed in trailing subscript in the colorbar label.')
parser.add_option('', '--point-size', type='float', default=None, help='Size to use for points; if none provided, a size is chosen based on the number of points in the plot.')
parser.add_option('-o', '--output-dir', default='.', help = 'directory to save plot(s) to')
parser.add_option('-u', '--user-tag', help = 'set a user tag for output file names')
parser.add_option('', '--plot-type', default = 'png', help = 'type of plot to create; default is png')
parser.add_option('', '--dpi', type='int', default=300, help='DPI to use for plot. Default is 300.')
parser.add_option('', '--cmap', default='Reds', help='Color map to use for points. Options are %s. Default is Reds.' %(', '.join(plot.pyplot.cm._cmapnames)))
parser.add_option('', '--bkg-color', default='k', help='Set the background color for the axis. Default is "k" (black).')
parser.add_option('', '--save-data', action='store_true', default=False, help='Save the plotting data to a pickle file. The file will have the same name as the output plot, but with a .pickle extension.')

opts, _ = parser.parse_args()

xarg, xlabel = opts.x_val.split(':')
yarg, ylabel = opts.y_val.split(':')
if opts.x_lims is not None:
    xmin, xmax = map(float, opts.x_lims.split(','))
else:
    xmin, xmax = (None, None)
if opts.y_lims is not None:
    ymin, ymax = map(float, opts.y_lims.split(','))
else:
    ymin, ymax = (None, None)
if opts.z_lims is not None:
    zmin, zmax = map(float, opts.z_lims.split(','))
else:
    zmin, zmax = (None, None)
if opts.user_tag is not None:
    tag = '_%s' % opts.user_tag
else:
    tag = ''

# make sure the output directory exists
if not os.path.exists(opts.output_dir):
    raise IOError("output-dir does not exist")

# load layers if desired
if opts.layer_config_file is not None:
    layers = efficiency.create_layers_from_config(opts.layer_config_file)
    pcubes = efficiency.get_all_cubes_in_layers(layers[0])
else:
    # just create an empty phyper cube; this will cause all of the data
    # to be plotted
    pcubes = [efficiency.PHyperCube()]

print "getting results"
filenames = plot.parse_results_cache(opts.cache_file)
results, _ = plot.overlaps.get_injection_results(filenames,
    weight_function=opts.weight_function, verbose=True)
apply_cut = {}
for thiscut in opts.apply_cut:
    arg, vals = thiscut.split(':')
    apply_cut[arg] = map(float, vals.split(','))
if apply_cut:
    print "applying cuts"
    results = plot.slice_results(results, apply_cut)
if opts.plot_templates:
    print "getting templates"
    ii = 0
    templates = []
    while not templates:
        try:
            templates = plot.get_templates(filenames[ii])
        except:
            pass
        ii += 1
        if ii >= len(filenames):
            break

else:
    templates = []

# group results by injection waveform approximant
approximants = set([r.apprx for r in results])
if len(approximants) > 1:
    inj_results = dict([ [approx, [r for r in results if r.apprx == approx]]
        for approx in approximants])
else:
    inj_results = {approximants.pop(): results}

print "plotting..."
for apprx, results in inj_results.items():
    print "\t%s" % apprx
    for ii,pcube in enumerate(pcubes):
        print "%i / %i\r" %(ii+1, len(pcubes)),
        sys.stdout.flush()
        # slice these results
        these_results = plot.slice_results(results, pcube.bounds)
        # if no results in this cube, just skip so we don't waste time making
        # empty plots
        if these_results == []:
            continue
        fig, _, _ = overlaps.plot_effectualness.plot_effectualness(
            these_results, xarg, xlabel, yarg, ylabel, opts.tmplt_label,
            opts.inj_label, logx=opts.log_x, logy=opts.log_y,
            plot_templates=opts.plot_templates, templates=templates,
            xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, zmin=zmin, zmax=zmax,
            ptsize=opts.point_size, cmap=opts.cmap, bkgclr=opts.bkg_color,
            dpi=300)
        if pcube.id_in_layer is not None:
            level_id, idx_id = pcube.id_in_layer
            if idx_id == -1:
                idx_tag = '-%i' %(level_id)
            else:
                idx_tag = '-%i-%i' %(level_id, idx_id)
        else:
            idx_tag = ''
        figname = '%s/plot_effectualness%s_%s%s.%s' %(opts.output_dir, tag,
            apprx, idx_tag, opts.plot_type)
        fig.savefig(figname, dpi=opts.dpi, bbox_inches='tight')
        # add to the cube's list of additional plots
        pcube.additional_plots.append(figname)
print ""

# save the file cache if there is more than one entry
if len(pcubes) > 1:
    cachename = '%s/plot_effectualness%s.cache' %(opts.output_dir, tag)
    efficiency.write_plot_cache(cachename, layers[0], opts.layer_config_file)
