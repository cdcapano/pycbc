#! /usr/bin/env python

import os,sys
import sqlite3
from optparse import OptionParser
import math
import numpy
from pycbc import plot
from pycbc.plot import overlaps
from pycbc.plot import plot_utils
from pycbc.plot import efficiency

__prog__ = 'pycbc_plot_effectualness_cumhist'
__author__ = 'Collin Capano <collin.capano@ligo.org>'
__description__ = 'Makes a cumulative histogram of the effectualness of a set of injections.'
__usage__ = '%s [OPTIONAL_COMMANDS] CACHE_FILE1.cache[:LABEL1:COLOR1:LINESTYLE1:uniform|WEIGHT_FUNCTION:APPROXIMANT] CACHE_FILE2.cache[:LABEL2:COLOR2:LINESTYLE2:uniform|WEIGHT_FUNCTION:APPROXIMANT] ...' % __prog__

parser = OptionParser(description=__description__, usage=__usage__)
parser.add_option('-P', '--apply-cut', action = 'append', default = [], metavar = 'arg:min,max', help='Only include injections that have the given argument in the given range. If specified multiple times, only injections passing all specified cuts will be plotted.')
parser.add_option('', '--layer-config-file', help='If provided, a plot will be created for each tile in the given config file. All of the plot names will be written out to a cache file.')
parser.add_option('--log-y', action='store_true', default=False, help='Make y-axis log10.')
parser.add_option('-X', '--x-lims', metavar = 'xmin,xmax', help = 'x limits to use')
parser.add_option('-Y', '--y-lims', metavar = 'ymin,ymax', help = 'y limits to use')
parser.add_option('-T', '--tmplt-label', default='', help='set a label for the templates. This will be placed in leading subscript in the colorbar label.')
parser.add_option('-I', '--inj-label', default='', help='set a label for the injections. This will be placed in trailing subscript in the colorbar label.')
parser.add_option('-B', '--plot-bar', action='store_true', help='Plot the cumulative histogram as a bar plot. Default is False.')
parser.add_option('-N', '--nbins', type='int', default=20, help='The number of bins to use. This is only used if plot-bar is on. Default is 20.')
parser.add_option('-M', '--target-mismatch', type='float', default=0.97, help='The minimal match of the bank. Default is 0.97.')
parser.add_option('-o', '--output-dir', default='.', help = 'directory to save plot(s) to')
parser.add_option('-u', '--user-tag', help = 'set a user tag for output file names')
parser.add_option('', '--plot-type', default = 'png', help = 'type of plot to create; default is png')
parser.add_option('', '--dpi', type='int', default=300, help='DPI to use for plot. Default is 300.')
parser.add_option('', '--save-data', action='store_true', default=False, help='Save the plotting data to a pickle file. The file will have the same name as the output plot, but with a .pickle extension.')

opts, cache_files = parser.parse_args()

if opts.x_lims is not None:
    xmin, xmax = map(float, opts.x_lims.split(','))
else:
    xmin, xmax = (None, None)
if opts.y_lims is not None:
    ymin, ymax = map(float, opts.y_lims.split(','))
else:
    ymin, ymax = (None, None)
if opts.user_tag is not None:
    tag = '_%s' % opts.user_tag
else:
    tag = ''

# load layers if desired
if opts.layer_config_file is not None:
    layers = efficiency.create_layers_from_config(opts.layer_config_file)
    pcubes = efficiency.get_all_cubes_in_layers(layers[0])
else:
    # just create an empty phyper cube; this will cause all of the data
    # to be plotted
    pcubes = [efficiency.PHyperCube()]

apply_cut = {}
for thiscut in opts.apply_cut:
    arg, vals = thiscut.split(':')
    apply_cut[arg] = map(float, vals.split(','))

print "Cycling over cache files:"
all_results = []
labels = []
colors = []
linestyles = []
for ii,cache_file_arg in enumerate(cache_files):
    print "%i / %i" %(ii+1, len(cache_files))
    # parse the cache file arguments
    cache_file_arg = cache_file_arg.split(':')
    if len(cache_file_arg) == 1:
        cache_file = cache_file_arg[0]
        label = color = linestyle = approx = None
        weight_function = 'uniform'
    elif len(cache_file_arg) == 2:
        cache_file, label = cache_file_arg
        color = linestyle = approx = None
        weight_function = 'uniform'
    elif len(cache_file_arg) == 3:
        cache_file, label, color = cache_file_arg
        linestyle = approx = None
        weight_function = 'uniform'
    elif len(cache_file_arg) == 4:
        cache_file, label, color, linestyle = cache_file_arg
        approx = None
        weight_function = 'uniform'
    elif len(cache_file_arg) == 5:
        cache_file, label, color, linestyle, weight_function = cache_file_arg
        approx = None
    elif len(cache_file_arg) == 6:
        cache_file, label, color, linestyle, weight_function, approx = cache_file_arg
    else:
        raise ValueError("cache file %s is not in correct format; " %(
            cache_file_arg) + "see help message")

    if label == '':
        label = None
    if color == '':
        color = None
    if linestyle == '':
        linestyle = None
    if weight_function == '':
        weight_function = 'uniform'
    if approx == '':
        approx = None

    print "  getting results"
    filenames = plot.parse_results_cache(cache_file)
    results, _ = plot.overlaps.get_injection_results(filenames,
        weight_function=weight_function, verbose=True)
    if apply_cut:
        print "  applying cuts"
        results = plot.slice_results(results, apply_cut)

    # get the desired approximant
    if approx is not None:
        # if approximant specified only get that approximant
        results = [x for x in results if x.apprx == apprx]
        if results == []:
            raise ValueError("approximant %s not found " %(approx) +\
                "in the databases in cache %s" %(cache_file))
    all_results.append(results)
    labels.append(label)
    colors.append(color)
    linestyles.append(linestyle)

print "plotting..."
print "plotting"
for ii,pcube in enumerate(pcubes):
    print "%i / %i\r" %(ii+1, len(pcubes)),
    sys.stdout.flush()
    # slice the results
    these_results = [plot.slice_results(results, pcube.bounds) \
        for results in all_results]
    # if no results in this cube, just skip so we don't waste time making
    # empty plots
    if these_results == []:
        continue
    fig, plot_data = overlaps.plot_effectualness.plot_effectualness_cumhist(these_results,
        labels=labels, colors=colors, linestyles=linestyles,
        tmplt_label=opts.tmplt_label, inj_label=opts.inj_label,
        target_mismatch=opts.target_mismatch,
        xmin=xmin, xmax=xmax, ymin=ymin,
        ymax=ymax, logy=opts.log_y, dpi=opts.dpi)

    if pcube.id_in_layer is not None:
        level_id, idx_id = pcube.id_in_layer
        if idx_id == -1:
            idx_tag = '-%i' %(level_id)
        else:
            idx_tag = '-%i-%i' %(level_id, idx_id)
    else:
        idx_tag = ''
    figname = '%s/plot_effectualness_cumhist%s%s.%s' %(opts.output_dir,
        tag, idx_tag, opts.plot_type)
    fig.savefig(figname, dpi=opts.dpi, bbox_inches='tight')
    # add to the cube's list of additional plots
    pcube.additional_plots.append(figname)
print ""

# save the file cache if there is more than one entry
if len(pcubes) > 1:
    cachename = '%s/plot_effectualness_cumhist%s.cache' %(opts.output_dir, tag)
    efficiency.write_plot_cache(cachename, layers[0], opts.layer_config_file)
